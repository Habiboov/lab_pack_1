# __________________ мутирование значений __________________
print('__ мутирование значений __')
# Каждый раз, когда мы присваиваем переменной новое значение, мы записываем в нее новый объект либо примитив
# Это можно отследить с помощью функции id(), которая определяет адрес в памяти, по которому лежит объект
# Давайте узнаем, где лежит следующий примитив
string_var = 'Я тестовая строка'
print('Адрес строки:')
print(id(string_var))

# А теперь переприсвоим переменную с помощью оператора += (a += b эквивалентно a = a + b)
string_var += ', да к тому же еще и изменённая'
print('Адрес изменённой строки:')
print(id(string_var))
# Как вы можете заметить, это теперь новый объект, лежащий по новому адресу

# Честно говоря, тестовая строка (примитив) осталась по тому же адресу, где и была
another_string_var = 'Я тестовая строка'
print('Адрес строки, повторяющей первую:')
print(id(another_string_var))

# То есть две одинаковых строки - это на самом деле одна и та же строка!
# Так произошло потому что тип данных 'строка' является неизменяемым типом.
# Каждый раз, когда вы что-то добавляете к строке, вы просто создаёте новую строку по новому адресу.
# А предыдущая строка либо уничтожается сборщиком мусора, либо ждёт в памяти своего следующего вызова
# Сборщик мусора умный и сам знает когда нужно освободить память от объекта, вам не нужно об этом беспокоиться
# Но знать это полезно, если вы хотите программировать по настоящему

# Так происходит, потому что у иммутабельных примитивов нет внутри функций для их мутации
# Иммутабельные типы мы можем только переопределить, а переопределение - это всегда создание нового объекта

# Теперь разберем пример с мутабельным типом:
test_list = [1, 2, 3, 4, 5]
print('Адрес списка:')
print(id(test_list))

test_list.append(6)
print('Адрес списка после мутации:')
print(id(test_list))

# Как мы видим адрес остался тем же, но что будет, если мы переопределим весь список?
test_list = [1, 2, 3, 4, 5, 6]
print('Адрес списка после переопределения:')
print(id(test_list))
# Адрес новый, а значит и переменная тоже новая.
# Вот по сути и все отличие иммутабельных типов от мутабельных.
# Внутри объектов мутабельных типов есть функции для изменения значений объектов без их переопределения
# А внутри иммутабельных типов таких функций нет

# Неизменяемыми типами данных являются: число, булевы значения, кортежи.
# Изменяемые типы данных: список, множество, байтовые массивы, словари. Будьте с ними аккуратны!


# __________________ мутирование переданных в функцию значений __________________
print('__ мутирование переданных в функцию значений __')


# По сути внутри функций все тоже самое поведение повторяется, но проговорим его еще раз, чтобы устаканить все знания.
# Функция при передаче внутрь иммутабельных(не изменяемых) значений в каком-то смысле ведет себя как Лас-Вегас.
# Все, что произошло внутри функции с неизменяемыми значениями, внутри нее самой и остаётся.

def test_function(value):
    value = 'новое значение'


immumable_variable = 'Текст - это не мутабельный тип'
print('Значение текстовой переменной до вызова функции:')
print(immumable_variable)

test_function(immumable_variable)
print('Значение текстовой переменной после вызова функции:')
print(immumable_variable)


# несмотря на то, что внутри функции переменная переопределяется, это не влияет на immumable_variable
# Значит, когда мы прибавляем что-либо к строке, числу, или переопределяем кортеж или булево значение, то ...
# на самом деле внутри функции создаётся новая переменная.


# А теперь попробуем мутировать изменяемый тип данных внутри функции
def list_append(list, item):
    list.append(item)


test_list = [1, 2, 3]
print('Список и его адрес до мутации внутри функции:')
print(test_list)
print(id(test_list))
print('Список и его адрес после мутации внутри функции')
list_append(test_list, 4)
print(test_list)
print(id(test_list))


# Во-первых список изменился после работы функции, во-вторых адрес не изменился.
# То есть мы видим, что несмотря на то, что мутации происходят внутри функции, поведение остаётся тем же.

# ОДНАКО! Если вы пытаетесь переопределить внутри функции даже мутабельный объект, то вы все равно создадите новый.

def list_redefine(list_var):
    list_var = [1, 2]


test_list_two = [1, 2, 3, 4, 5]
print('Список и его адрес до переопределения внутри функции:')
print(test_list_two)
print(id(test_list_two))
print('Список и его адрес после переопределения внутри функции:')
list_redefine(test_list_two)
print(test_list_two)
print(id(test_list_two))


# Как мы видим список совсем не изменился!

# Запомним, что данные снаружи изменяются, если внутри функций вы их мутируете (изменяете)
# А если вы их переопределяете, то снаружи функции они не изменяются!


# Теперь пример, который взорвет вам мозг:
def list_mutate_and_redefine(list):
    print('Мутируем:')
    list.append(3)

    print(list)
    print(id(list))

    print('Переопределяем:')
    list = ['a', 'b', 'c']

    print(list)
    print(id(list))

    print('Мутируем переопределенное:')
    list.append('d')

    print(list)
    print(id(list))


test_list_three = [1, 2]
print('Список и его адрес до применения взрывающей мозг функции:')
print(test_list_three)
print(id(test_list_three))

list_mutate_and_redefine(test_list_three)
print('Список и его адрес после применения взрывающей мозг функции:')
print(test_list_three)
print(id(test_list_three))

# Что произошло? Сперва список мутировал, поэтому в него добавилась тройка
# Потом мы переопределили список внутри нашей функции, поэтому создался новый объект
# Мы мутировали уже новый объект, поэтому при второй мутации со старым объектом ничего не произошло
# И снаружи мы получили объект, который был изменен только единожды

# Погуглите про мутирование, чтобы иметь о нём еще большее представление
