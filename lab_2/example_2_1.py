# __________________ циклы и итерируемые объекты __________________
print('__ циклы и итерируемые объекты __')
# Типы данных, переменные и условия мы поняли, но мы ведь хотим не только уметь сравнивать между собой разные величины
# "Мы хотим писать серьезные большие программы!", скажите вы.
# Помимо переменных, данных и сравнений нам для этого необходимы будут циклы!
# Циклы нужны для того, чтобы обходить итерируемые объекты, либо выполнять код до тех пор, пока соблюдается условие

# Что такое "итерируемый объект"? Это любой объект, который можно... обойти циклически.
# Как, например вы квартира за квартирой обхъодите жилой дом, чтобы уведомить жителей о собрании.
# Когда вам нужно совершить одно и то же действие многократно - вам нужно использовать цикл.

# И так, итерируемые объекты в питоне это: списки, строки, кортежи, словари, файлы и созданные вами итерируемые объекты
# Самый простой пример такого объекта - это список.
example_list = [1, 2, 3, 4, 5, 6, 7]

# Посмотрим на список внимательно и представим, его как очередь в поликлинику.
# Как только один посетитель пройдет через регистратуру, другой сможет в нее попасть.
# В тот момент, когда регистратор разговаривает с кем-то, остальные ждут своей очереди.
# Также работают и циклы.

# Итерируемые объекты не имеют заданной величины, и мы не можем заранее знать, сколько элементов они в себе содержат.
# Чтобы итерировать (циклически обходить) такие объекты (даже те, что вы написали сами) в питоне существуют цикл for

# __________________ цикл for __________________
print('__ цикл for __')

# Синтаксис цикла for:
# После ключевого слова for вам нужно создать переменную, в которой будет храниться значение из итерируемого объекта
# После ключевого слова in вы помещаете объект, который вы хотите проитерировать
# Обратите внимание на двоеточие, после него мы размещаем весь код, который хотим выполнить над каждым элементом цикла

print('первый цикл:')
for iter_variable in [1, 2, 4, 8, 'никто не ждал строку в конце ряда из чисел!']:
    print(iter_variable)

# можно итерировать объекты, находящиеся в переменной, возьмём например example_list, объявленный в начале
print('второй цикл:')
for iter_variable in example_list:
    print('Я (строка) тут для демонстрации того, что я выведусь на экран при каждой итерации')
    print(iter_variable)

# Вы вольны делать внутри цикла все, что захотите. Давайте реализуем пример с поликлиникой, например:
print('пример с поликлиникой:')
queue = ['сердечник', 'орви', 'здоровый', 'сердечник', 'ковид', 'здоровый', 'орви']

for person in queue:
    if person == 'здоровый':
        continue
    if person == 'сердечник':
        print('Вам в 211 кабинет!')
    if person == 'орви':
        print('Вам в 324 кабинет!')
    if person == 'ковид':
        break
    print('Следующий!')
# Во первых мы видим, что весь код, который находится внутри цикла, имеет отступ в 4 пробела.
# Как и код внутри условий.
# Также мы увидели здесь два новых ключевых слова - continue и break.
# continue заставляет цикл сразу же начинать новую итерацию (даже если еще остался невыполненный код)
# break сразу же заканчивает весь цикл, даже если остались непроитерированные объекты

# __________________ цикл while __________________
print('__ цикл while __')
# Есть в питоне еще один цикл - while и выполняется он "до тех пор, пока"
# Сначала идет ключевое слово while, после этого условие, которое возвращает True либо False
# Например:
i = 1
while i < 10:
    i += 2
    print(i)
# Данный пример показывает нам, что сначала происходит проверка условия, а потом выполнение кода, но никак не наоборот
# Также в этом цикле работают выше упомянутые инструкции continue и break
print('__ цикл while, второй пример __')
j = 1
while j < 10:
    j += 2
    if j == 5:
        continue
    if j == 9:
        break
    print(i)
