# __________________ переменные __________________
print('__ переменные __')
# В Python мы можем создавать свои собственные переменные и класть в них все, что угодно:
# экземпляры классов, их чертежи (сами классы), функции, примитивы;
# В python все является объектом по своей природе. Примитивы - это по сути тоже объекты, но особого вида.
# Переменные подобны адресам в справочнике, в который мы записываем кто где живет.
# Еще переменные подобны коробкам, в которых может лежать только один объект (массив из объектов - это тоже один объект)
# В процессе работы мы можем создать переменную и положить в нее любой объект.
# Таким образом мы создаём объект и задаём ему "символьный адрес в справочнике объектов" (название переменной).

# Создадим переменную, пусть она будет равна "ничему". Ключевое слово None в питоне значит отсутствие значения.
# Если копнуть глубже, вы узнаете, что None - это примитив, но особый, означающий собой пустоту.
# Так или иначе, если вы видите "None", значит перед вами 'ничто', т.е. отсутствие какого-либо значения
test_variable = None

# Выведем значение переменной на экран с помощью функции print().
print('значение test_variable:', test_variable)
# Вывелось 'значение test_variable: None' (None значит "Ничего")

# Положим что-нибудь в переменную.
# Знак = (равно) - это операция присваивания (мы как бы говорим: "сделай test_variable равным 'что-нибудь'")
test_variable = 'что-нибудь'

# Выведем значение переменной на экран с помощью функции print().
print('значение test_variable:', test_variable)
# Вывелось 'значение test_variable: что-нибудь'
# Хотя строчка print('значение test_variable:', test_variable) та же, что и раньше.
# Дело тут в значении переменной, а оно у нас уже изменилось

# Тут важно упомянуть, что python - язык с динамической типизацией
# А это значит, что вы можете положить в переменную любое значение. И не важно, что там лежало до этого.
# В языках со статической типизацией вы можете положить в переменную данные только того типа, для которого вы ее создали

# __________________ удаление объектов из памяти __________________
print('__ удаление объектов из памяти __')


# Если "поселить" в переменную новый объект, то старый останется "без адреса"
# При присваивании вы "выселяете" объект из переменной
# Если у объекта после этого не останется действительных адресов, то он будет удалён из памяти.

# Забежим немного вперед и создадим свой класс с деструктором (функция __del__) для того, чтобы это продемонстрировать
# Деструктор вызывается при уничтожении объекта

class DelTest:
    def __del__(self):
        print('Я удалён, прощайте')


print('Создаём объект')
test_var = DelTest()

print('Оставляем объект без "адреса" в виде переменной, в которой он жил')
test_var = 'Новое значение'

# Выполнив этот код, мы увидим, что когда объект остался без переменной, он был удалён из памяти
# Мы зафиксируем это так как на экран выведется строчка 'Я удалён, прощайте', а это значит, что сработал деструктор

# Давайте теперь усложним наш пример, чтобы вы увидели, что у объекта может быть множество адресов, а не один

print('Создаём объект и копируем его в переменную object_ref')
# Создадим объект в переменной object
object = DelTest()
# Также положим его же в переменную object_ref
object_ref = object

print('Переопределяем первую переменную, в которой лежит объект')
object = 'новое значение'
print('Переопределяем вторую переменную, в которой лежит объект')
object_ref = 'новое значение'

# Мы видим, что когда мы положили в object новое значение, объект, который там лежал, не был удалён сразу
# Потому что он еще был доступен в переменной object_ref
# Однако, когда мы выселили объект еще и из object_ref, он был удалён так называемым "сборщиком мусора"
# Можете самостоятельно загуглить "сборщик мусора Python", чтобы узнать чуть больше о механизмах работы языка
