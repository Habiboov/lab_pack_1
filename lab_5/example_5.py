# __________________ реализация класса для работы с SQL через sqlite __________________
# Для того, чтобы научиться работать с реляционными базами данных, мы начнем с самых основ языка SQL
# Мы будем изучать работу с языком SQL на примере работы с БД SQLite, т.к. она встроена в пакет python

# Сперва импортируем пакет для работы с базами данных sqlite
import sqlite3

# Далее я написал для вас класс, чтобы вы могли сконцентрироваться на написании SQL-кода без ковыряния модуля sqlite3
class SQLiter:
    # Конструктор создаёт подключение к файлу, название которого было переданно в конструктор при создании экземпляра.
    # Если такого файла нет, то он его создаст. Также конструктор открывает объект курсора для общения с бд.
    # Курсор - это как будто бы окошечко, в которое вы отправляете команды и из которого получаете результат
    # Откровенно говоря, вы можете обойтись и без него, но это поведение нестандартно
    # А когда вы используете нестандартные решения, вам не гарантируется совместимость кода с новыми версиями
    def __init__(self, db_name):
        self.connection = sqlite3.connect(db_name)
        self.cursor = self.connection.cursor()

    # Деструктор уничтожает курсор и подключение, потому что они всегда должны быть закрыты по окончанию работы с бд
    # Деструктор сработает автоматически (неявно), когда на объект не останется действительных ссылок
    # (например, вы записали в единственную переменную, где лежал объект что-то другое)
    # Также деструктор срабатывает при переходе работы из области видимости, в которой был создан объект
    # (например объект существовал только внутри одной функции и выполнение дошло до ее конца)
    def __del__(self):
        if self.cursor:
            self.cursor.close()

        if self.connection:
            self.connection.close()

    # Функция execute выполняет sql-код и сохраняет изменения в бд, в случае, если они есть после выполнения команды
    # Также cursor возвращает результат выполнения запроса с помощью функции fetchall()
    # Если результата нет, то вернется пустой список.
    # Если модуль общения с БД вернёт исключение IntegrityError, то мы его обработаем и выведем на экран
    def execute(self, query):
        try:
            self.cursor.execute(query)
            self.connection.commit()
        except sqlite3.IntegrityError as e:
            print('Вы пытаетесь записать в бд дубликат уникального ключа: ', e)

        return self.cursor.fetchall()

# Давайте проверим работу нашего класса
db = SQLiter('test.db')
query_result = db.execute("SELECT 'test';")
print(query_result)
# Если мы получили на экране вывод кортежа с одним значением 'test' внутри него, значит все работает правильно.

# Однако все время дословно писать то, что мы хотим получить - это как-то странно, нам для этого и БД не нужна.
# А бд нужна затем, чтобы хранить внутри себя данные.

# __________________ Основы языка SQL __________________
print('__ Основы языка SQL __')
# Внутри реляционных БД данные хранятся в внутри таблиц.
# Доступный синтаксис создания таблиц довольно объемен и различается в разных системах управления БД (СУБД).
# Однако базовый синтаксис всегда одинаков.
# Создание таблицы: CREATE TABLE имя_таблицы, в скобочках столбцы с их типами данных и свойствами
# (имя_столбца тип_столбца свойства)

# Например:
db.execute('CREATE TABLE IF NOT EXISTS test_table (id INTEGER PRIMARY KEY, test_column TEXT);')
# PRIMARY KEY - свойство, обозначающее, что столбец будет являться уникальным идентификатором (как ваш номер паспорта)
# Уникальный идентификатор нужен, чтобы однозначно можно было найти и идентифицировать строку
# INTEGER и TEXT - типы данных в sqlite БД.
# Типы данных в каждой СУБД тоже свои (но могут быть и одинаковыми при конкретном сравнении двух разных СУБД)
# Чтобы как-то сориентироваться на первых порах, запомните, что во всех СУБД (которые я знаю) точно есть типы ЧИСЛО, ЧИСЛО С ПЛАВАЮЩЕЙ ЗАПЯТОЙ, ТЕКСТ
# IF NOT EXISTS - это фраза указывающая на то, что таблицу нужно создать только если она еще не существует

# Для того, чтобы начать работать с языком SQL, нам надо освоить как минимум 3 команды: select, insert и update
# Команду delete мы разбирать не будем, т.к. в корпоративных системах никто никакие данные никогда не удаляет
# (удаляют только в исключительных случаях)

# __________________ INSERT INTO __________________
# Чтобы данные появились внутри БД, нам их туда нужно сперва вставить. За это отвечает команда INSERT INTO.
# У нее довольно простой синтаксис - INSERT INTO, название таблицы, перечисление столбцов для вставки, если нужно и перечисление значений для вставки.

db.execute("INSERT INTO test_table (id, test_column) VALUES (1, 'Первая строка');")
db.execute("INSERT INTO test_table VALUES (2, 'Вторая строка');")
# Во втором случае перечисление столбцов отсутствует потому что их можно не перечислять, если вы вставляете данные во все столбцы строки
# Также, если вы запускаете данный файл не первый раз, то могли обратить внимание на обработанное исключение
# А именно на вывод UNIQUE constraint failed: test_table.id
# Ошибка возникла из-за того, что мы пытаемся записать в столбец с уникальным идентификатором не уникальное значение.
# А так делать нельзя.

# __________________ SELECT __________________
# И так, данные внутри таблиц у нас уже есть, теперь логичным шагом будет чтение этих самых данных
# Синтаксис команды SELECT чуть сложнее, но базовый синтаксис все равно довольно прост:
# SELECT необходимые_столбцы FROM имя_таблицы WHERE условия_для_строк ORDER BY столбцы_для_сортировки порядок_сортировки

# Также в SELECT запросах можно объединять данные из разных строк по зачению столбка с помощью GROUP BY и фильтровать их после этого с помощью HAVING
# Но мы начнём изучение с азов. Если вы хотите выбрать все столбцы, то можете вместо них указать символ *

# Выбираем все строки со всеми столбцами из таблицы test_table
print(db.execute("SELECT * FROM test_table;"))
# Выбираем все строки из таблицы test_table, но включающие в себя только столбец test_column
print(db.execute("SELECT test_column FROM test_table;"))
# Выбираем все строки со всеми столбцами из таблицы test_table в которых столбец id равен 1
print(db.execute("SELECT * FROM test_table WHERE id = 1;"))

# __________________ UPDATE __________________
# Пока что нам хватит этого для того, чтобы выбирать данные из БД, перейдем к UPDATE запросам
# UPDATE-запрос состоит из ключевого слова UPDATE имя_таблицы SET имя_столбца = новое_значение WHERE условие
db.execute("UPDATE test_table SET test_column = 'Вторая изменённая строка' WHERE id = 2")
# С UPDATE запросами стоит быть внимательным, потому что если вы выполните UPDATE без условий, то обновятся все строки.
